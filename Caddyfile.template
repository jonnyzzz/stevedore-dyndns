# Stevedore DynDNS - Caddy Configuration Template
# This file is processed by the dyndns service to generate the final Caddyfile

{
    # Global options
    email {{.AcmeEmail}}

    # Use Let's Encrypt production (change to staging for testing)
    # acme_ca https://acme-staging-v02.api.letsencrypt.org/directory

    # HTTP/3 is enabled by default in Caddy 2.6+

    # Logging
    log {
        level {{.LogLevel}}
        output file /var/log/dyndns/caddy.log {
            roll_size 10mb
            roll_keep 5
        }
    }
}

# Certificate configuration
# In prefix mode: certificates for basedomain.com (parent of zone.basedomain.com)
# In normal mode: wildcard certificate for *.domain and domain itself
{{if .SubdomainPrefix}}
# Prefix mode: service subdomains are direct children of {{.BaseDomain}}
# e.g., app-zone.example.com instead of app.zone.example.com
*.{{.BaseDomain}}, {{.Domain}} {
{{else}}
# Normal mode: wildcard subdomain certificate
*.{{.Domain}}, {{.Domain}} {
{{end}}
    # TLS with Cloudflare DNS challenge for wildcard cert
    tls {
        dns cloudflare {env.CLOUDFLARE_API_TOKEN}
{{if .CloudflareProxy}}
        # Require Cloudflare client certificate for Authenticated Origin Pull (mTLS)
        # This ensures only Cloudflare can connect to the origin
        client_auth {
            mode require_and_verify
            trusted_ca_cert_file /etc/cloudflare/origin-pull-ca.pem
        }
{{end}}
    }

    # Access logs (streamed to container stdout via entrypoint)
    log {
        output file /var/log/dyndns/caddy-access.log {
            roll_size 10mb
            roll_keep 5
        }
        format json
    }

    # Dynamic routing based on subdomain
    {{range .Mappings}}
    @{{.Subdomain}} host {{.FQDN}}
    handle @{{.Subdomain}} {
        reverse_proxy {{.Target}} {
            {{if .Options.Websocket}}
            # WebSocket support - force HTTP/1.1 for proper upgrade handling
            # Note: Caddy automatically handles WebSocket upgrade headers with HTTP/1.1
            transport http {
                versions 1.1
            }
            {{end}}
            {{if not .Options.BufferRequests}}
            flush_interval -1
            {{end}}
            # Health checks
            health_uri {{.Options.HealthPath | default "/health"}}
            health_interval 30s
            health_timeout 5s

            # Headers
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
            header_up X-Forwarded-Host {host}
        }
    }
    {{end}}

    # Default handler for unmatched subdomains
    handle {
        respond "Not Found" 404
    }
}

# Health check endpoint (internal only, bound to localhost for security)
127.0.0.1:8080 {
    handle /health {
        respond "OK" 200
    }

    handle /status {
        # Returns JSON status (handled by Go service)
        reverse_proxy 127.0.0.1:8081
    }

    handle {
        respond "Not Found" 404
    }
}
